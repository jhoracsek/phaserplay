

//min, max inclusive
function randInt(min, max) {
  return Math.floor(Math.random() * ((max+1) - min) ) + min;
}

function generateRoomID(){
  const chars = '0123456789abcdefghijklmnopqrstuvwxyz'
  let ret = ""
  for(let i = 0; i < 5; i++){
    ret+=chars[randInt(0,35)]
  }
  return ret;
}

function hash(roomID){
  let hash = 0;
    for (let i = 0, len = roomID.length; i < len; i++) {
        let chr = roomID.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash%100;
}

//Make a large array that's like 10067
var big = 100;
/*
  So what servers will actually be is an array of arrays where
  servers[12][0] is a Server object.

  Server objects have the attributes: roomID, playerList, and playerName.
  Equality == should be comparing roomID
*/
var rooms = new Array(big);

class Room{
  constructor(roomID){
    this.roomID = roomID;
    this.playerList = [];
    this.playerName = [];
  }
}

/*
  Returns the room object from the array rooms
*/
function getRoomObj(roomID){
  let ind = hash(roomID)
  for(let i = 0; i < rooms[ind].length; i++){
    if(roomID == rooms[ind][i].roomID){
      return rooms[ind][i];
    }
  }
  //Cannot find a room object associated with this roomID, so return null
  return null;
}

function generateNewRoom(){
  var unique = true;
  var retRoomID = "";
  do{
    unique = true;
    let roomID = generateRoomID();
    let ind = hash(roomID);
    //We need to make sure rooms[ind] is an array
    if(rooms[ind] == null){
      //Wow we love this idea
      rooms[ind] = [new Room(roomID)]
    }else{
      //This is the situation where either:
      //(a) We have a collision where every ID in rooms[ind] is unique from the current "roomID"
      //(b) We have a collision where there is an index j such that rooms[ind][j].roomID == roomID
      //In case (b) we need to restart the function with a new roomID. (So this should all be contained in a while loop)
      for(let j = 0; j < rooms[ind].length; j++){
        //Oh no, we have to regenerate the ID :(
        //Statistically this is extremely unlikely to happen...
        if(rooms[ind][j].roomID == roomID){
          unique = false;
          break;
        }
      }
      if (unique){
        rooms[ind].push(new Room(roomID));
      }
    }
    retRoomID = roomID;
  }while(!unique);
  return retRoomID;
}

for(let i = 0; i < 150; i++){
  generateNewRoom()
}


/*
for(let i = 0; i < rooms.length; i++){
  console.log('i = '+i);
  if(rooms[i] != null){
    for(let j = 0; j < rooms[i].length; j++){
      console.log(rooms[i][j].roomID);
    }
  }
}
*/