<!DOCTYPE html>
<html>
<head>
    <!-- <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script> !-->
    <script src="./phaser.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <title> pikcel - Some Nonsense </title>
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
    <center>
        
        <div id="game-container", class="cent">
            <div  class = "splash" id = "splsh">
                <div class="splashLeft">
                    <h2>How to play</h2>
                </div>
                <div class="splashTopRight">
                    <h2>Announcements</h2>
                </div>
                <div class="splashBottomRight">
                    <h2>About</h2>
                </div>



                <!----------- CONTENTS OF SPLASH PAGE-------------------->
                <div class="splashWindow"> 
                   <div class="splashContent">
                        <h2 style="color:black;">Welcome to PiKCEL.io!</h2>
                        <!--https://stackoverflow.com/questions/18022019/how-to-transfer-data-from-an-html-form-to-a-javascript-function-->
                        <form autocomplete="off" action="javascript:setName();" method="get">
                            <input class="splashInput" type="text" placeholder="What's your name?" name="pn" id="pn"><br>
                            <hr>
                            <input class="buttonStyle1" style="text-decoration: line-through;" type="submit" value="--Find a Game--">
                            
                        </form>
                        <hr>
                        <form action="javascript:createWaitRoom();" method="get">
                            <input class="buttonStyle1" type="submit" value="Create Private Room">
                        </form>
                        <!-- OLD <form action="javascript:resetBoard();" method="get">
                            <input type="submit" value="reset">
                        </form> -->
                            <hr>
                        <form autocomplete="off" action="javascript:joinWaitRoom();" method="get">
                            <input class="splashInput" type="text" placeholder="Room ID" name="customRoomID" id="customRoomID"><br>
                            <input class="buttonStyle2" type="submit" value="Join Existing Room">
                        </form>


                    </div>
                    <div style="position:absolute; bottom:4px; right:4px">PiKCEL.io Pre-alpha</div>
                </div>
            </div>

            <!-------------WAITING MENU CONTENT----------------------->
            <div class="waitingWinNames" id="waitingWinNames">
                <div id = "namesToDisplay"></div>
            </div>
            <div class = "plrCount" id = "plrCount">(1/4)</div>
            <div class="waitingWin" id="waitingWindow" >
                <div id ="rmid"> Room ID: 00000 </div>
                <form action="javascript:goToGame();" method="get">
                    <input class="buttonStyle1" type="submit" value="Start">
                </form>

            </div>

            <!-------------CHAT CONTENT FOR GAME---------------------->
            <div class="chatInput" id ="cht">
                <form autocomplete="off" action="javascript:sendMessage();" method="get">
                    <input class="inputText" type="text" name="msg" id="msg" placeholder="Send message"><br>
                </form>
            </div>
            
            <div class= "chatWindow" id="cw"><div class="chatContent" id = "cww"></div></div>
        </div>
        
    </center>
    <script type="text/javascript" src="helpees.js"></script>

    <script type="text/javascript">


    var socket = io();
    var tempx = 0;
    var tempy = 0;
    var playerColor = null;

    var initialized = false;

    const playerColours = ['0xFF0000', '0x00FF00', '0x0000FF', '0xF0F0F0'];
    var playerList = [];
    var playerNames = [];

    var myName = "";

    var shadowOffset = 5;

    var tttt = 1;

    var splash = true;

    const msgWin = document.getElementById('cww');

    var roomID = '-1-1-1-1-1';

    class PlayerBadges{
        constructor(posX, posY){
            this.posX = posX;
            this.posY = posY;

            this.playerText = null;
            this.graphics = null;
            this.scene = null;

            this.playerBoxes = [];
            this.playerTexts = [];

            this.boxShadows = [];
        }

        create(scene, graphics){
            this.graphics = graphics;
            this.scene = scene;
        }

        resetBoxes(){
            while(this.playerBoxes.length > 0){
                this.removePlayerBox();
            }

            this.playerBoxes = [];
            this.playerTexts = [];
            this.boxShadows = [];
        }

        addAllPlayerBoxes(){
            this.resetBoxes();
            var first = true;
            var last = false;
            for(const box in playerNames){
                if (box == playerNames.length-1){
                    last = true;
                }
                this.addPlayerBox(box, first, last);
                first = false;
            }
        }

        addPlayerBox(num, first, last){
                let n = this.playerBoxes.length;

                let height = 170+n*50;

                let boxHeight = 50;
                let boxWidth = 250;

                const boxx = this.scene.add.graphics();

                //https://labs.phaser.io/edit.html?src=src/display/masks/graphics%20bitmap%20mask.js&v=3.70.0
                var top = 0;
                var bot = 0;
                if(first==true){
                    top = 5;
                }
                if(last==true){
                    bot = 5;
                }
                const maskGraphics = this.scene.make.graphics();
                maskGraphics.fillStyle(0xFFFFFF);
                maskGraphics.fillRoundedRect(31, height,boxWidth,boxHeight, { tl: top, tr: top, bl: bot, br: bot });

                const mask = new Phaser.Display.Masks.GeometryMask(this, maskGraphics);

                var c1=0xEFEFEF;
                var c2=0xeaeaea;

                boxx.fillGradientStyle(c1, c1, c2, c2, 1);
                var toBeMasked = boxx.fillRect(31, height,boxWidth,boxHeight);
                mask.dirty = true;
                toBeMasked.setMask(mask);
                this.playerBoxes.push(toBeMasked);
                //console.log(playerColor)
                var pt = this.scene.add.text(Math.round(31+boxWidth/2), Math.round(height+boxHeight/2), playerNames[num]).setFontFamily('Arial').setFontSize(17).setColor('#6b4ea2').setOrigin(0.5, 0.5)//.setStroke('#'+playerColor.slice(2, 8), 5);
                pt.antialias = true;

                this.playerTexts.push(pt);
                boxx.fillStyle(0x000000,1);

                const shadowGraphic = this.scene.add.graphics();
                shadowGraphic.setDepth(-2);
                shadowGraphic.fillStyle(0x000000,0.17);
                
                this.boxShadows.push(shadowGraphic.fillRoundedRect(31+shadowOffset, height+shadowOffset,boxWidth,boxHeight, { tl: top, tr: top, bl: bot, br: bot }));

        }

        removePlayerBox(){
            var rect = this.playerBoxes.pop();
            var text = this.playerTexts.pop();
            var shad = this.boxShadows.pop();
            rect.destroy();
            text.destroy();
            shad.destroy();
        }

        update(){

        }


    }

 
    var pbs = new PlayerBadges(0,0);

    var board = new Array(16);
    for (let i = 0; i < 16; i++){
        board[i] = new Array(16);
    }
    for(let i = 0; i < 16; i++){
        for(let j = 0; j < 16; j++){
            board[i][j] = '0x111111';
        }
    }




    class Pixel {
        constructor(posX, posY, size, x, y){
            this.x = x;
            this.y = y;
            this.posX = posX;
            this.posY = posY;
            this.size = size;
            this.pix = null;
            this.virgin = true;
            this.fx = null;
        }

        update(posX, posY, size, x, y){
            this.x = x;
            this.y = y;
            this.posX = posX;
            this.posY = posY;
            this.size = size;
        }

        create(graphics, scene){
            this.graphics = graphics;
            //var pix = scene.add.rectangle(this.posX+this.size/2, this.posY+this.size/2, this.size, this.size, board[this.x][this.y]);
            var pix = scene.add.rectangle(this.posX+this.size/2, this.posY+this.size/2, this.size, this.size, board[this.x][this.y]);
            this.pix = pix;

            this.updateColor(board[this.x][this.y])
            
            pix.setInteractive()
            pix.on('pointerdown', (pointer)=>
            {
                pix.setFillStyle(playerColor);
                board[this.x][this.y] = playerColor;
                socket.emit('board update', playerColor, this.x, this.y, roomID);
            });


        }

        updateColor(color){

            if(this.pix != null){
                this.pix.setFillStyle(color);

                //If it's a default colour, just draw it above the shine, otherwise just draw it below.
                if(color == '0xEFEFEF' || color == '0xFFFFFF'){
                    this.pix.setDepth(3);
                }else{
                    
                    this.pix.setDepth(1);
                    //this.pix.postFX.addShine(1, .2, 5);
                }
            }
        }
    }


    var pixStore = new Array(16);
    for (let i = 0; i < 16; i++){
        pixStore[i] = new Array(16);
    }
    for(let i = 0; i < 16; i++){
        for(let j = 0; j < 16; j++){
            const pixel = new Pixel(0,0,0,0,0);
            pixStore[i][j] = pixel;
        }
    }



    class Grid {
        constructor(posX, posY, players){
            this.posX = posX;
            this.posY = posY;
            this.players = players;
            this.size = 96*6;

            // 2 player should be 16x16
            // 3 player should be 24x24
            // 4 player should be 32x32
            this.gridPixelSize = 0;
            switch(players){
                case 2:
                    this.gridPixelSize = 16;
                    break;
                case 3:
                    this.gridPixelSize = 24;
                    break;
                default:
                    this.gridPixelSize = 32;
            }
            this.lineSep = this.size/this.gridPixelSize;
            this.lineWidth = 1.0;
        }

        create(graphics, scene){
            var x = 0;
            var y = 0;
            const pixelGraphics = scene.add.graphics();


            for(let i = 0; i < this.size; i+= this.lineSep){
                for(let j = 0; j < this.size; j+= this.lineSep){
                    pixStore[x][y].update(this.posX+i,this.posY+j,this.lineSep, x, y);
                    pixStore[x][y].create(pixelGraphics, scene);
                    y+=1;
                }
                x+=1;
                y=0;
            }
            //const fx = pixelGraphics.postFX.addShine(1, .2, 5);
            //May not even include these lines
            graphics.setBlendMode(Phaser.BlendModes.NORMAL);
            // This is a good complementary colour but idk if it fits.
            // https://www.canva.com/colors/color-wheel/
            // 85a24e           OLD:0xFFF000
            graphics.lineStyle(this.lineWidth,0x6b4ea2,2,1);
            for(let i = this.lineSep; i < this.size; i+=this.lineSep){
                graphics.lineBetween(this.posX, this.posY + i, this.posX+this.size, this.posY+i);
            }
            for(let i = this.lineSep; i < this.size; i+=this.lineSep){
                graphics.lineBetween(this.posX+i, this.posY, this.posX+i, this.posY+this.size);
            }

            graphics.strokeRect(this.posX,this.posY,this.size,this.size);
        }

        update(){

        }


    }

    //https://css-tricks.com/moving-backgrounds/
    let container = document.querySelector("body");
    var bgX = 0;
    var bgY = 0;
    class Game extends Phaser.Scene
    {
        constructor(){
            super('Game');
        }
        preload ()
        {
            this.load.image('logo', 'images/logo.png');
            this.load.image('shine', 'images/shine.png');
        }

        create ()
        {
            this.logo = this.add.image(100, 50, 'logo');
            this.logo.setDepth(10);
            this.logo.setScale(4);
            this.logo.setOrigin(0.5,0.5);
            this.logo.x = 600;
            this.logo.y = 120;


            var gridPosX = 312;
            var smallBoxStart = (1200-500-576)/4;

            const grid = new Grid(gridPosX, 170, 2);
            const graphics = this.add.graphics();
            const shadows = this.add.graphics();

            grid.create(graphics, this);

            var startL = 3*smallBoxStart + 250 + 576;
            var startT = 170;
            var endT = 776;

            pbs.create(this, graphics);
            graphics.fillStyle('0xf7f7f7',1);
            graphics.setDepth(1);
            
            var divElement = this.add.dom(0, 0, 'div');
            divElement.innerHTML = '<b>This is an embedded HTML element.</b>';

            shadows.fillStyle(0x000000, 0.17);

            //-------------------------------------------------
            //Right

            
            //TOP RIGHT====
            graphics.fillRoundedRect(startL, startT,250,273,6);
            shadows.fillRoundedRect(startL+shadowOffset, startT+shadowOffset,250,273,6);
            //=============

            //BOTTOM RIGHT====
            graphics.fillRoundedRect(startL, startT+303,250,273,6);
            shadows.fillRoundedRect(startL+shadowOffset, startT+303+shadowOffset,250,273,6);
            //================

            //-----------------------------------------------
            //Top

            graphics.setDepth(4);
            var topBoxStart = 2*smallBoxStart + 576 + 2*250;
            

            //GRID SHADOW
            shadows.setDepth(-5);
            
            shadows.fillRect(gridPosX+shadowOffset, 170+shadowOffset,576,576);


            shadows.fillStyle(0x6b4ea2, 0.5);
            shadows.fillRect(gridPosX-3, 170-3,576+6,576+6,6);


            // GRID SHINE =============================================

            // gridUnderlay serves as our mask for the shine.
            var gridUnderlay = this.add.rectangle(gridPosX+288,170+288,576,576,0xFFFFFF,0.2);

            // This should essentially be hidden under everything in our canvas.
            gridUnderlay.setDepth(-10);

            // This is the actual shine that will appear over our grid.
            let shine = this.add.image(190, 190-75, 'shine');
            shine.setDepth(2);
            shine.rotation = -Math.PI/4;
            shine.setBlendMode(Phaser.BlendModes.ADD);


            // We mask the shine so it only appears within the confines of gridUnderlay.
            const mask = new Phaser.Display.Masks.BitmapMask(this, gridUnderlay);
            shine.setMask(mask);

            //This is the animation associated w/ the shine.
            this.tweens.add({
                targets: shine,
                x: 960,
                y: 960-75,
                //yoyo:true,
                repeat:-1,
                repeatDelay: 2000,
                duration:800,
            });
            
            
            // ========================================================

            

            //Logo animation
            pbs.addAllPlayerBoxes();
                this.tweens.add({

                targets: this.logo,
                duration: 1000,
                scaleX: 3.75,
                scaleY: 3.75,

                //Sine.easeInOut
                ease: 'Phaser.Math.Easing.Linear',
                repeat: -1,
                yoyo: true
            });
           
        }

        update(){
            //This seriously might be a problem......... Need to fix this..... ASAP THIS IS A BIG PRIORITY
            //IT ISN'T FIXED YET PLEASE FIX IT SOON IT WON'T BE HARD!!!            
            bgX += 0.5;
            bgY -= 0.5;
            container.style.backgroundPositionX = bgX + "px";
            container.style.backgroundPositionY = bgY + "px";
        }
    }


    var menuScene = null;
    var frame = 0;
    class Menu extends Phaser.Scene
    {
        preload ()
        {
            this.load.image('logo', 'images/logo.png');
        }

        create ()
        {
            menuScene = this;
            this.logo = this.add.image(100, 50, 'logo');
            this.logo.setDepth(10);
            this.logo.setScale(4);
            this.logo.setOrigin(0.5,0.5);
            this.logo.x = 600;
            this.logo.y = 120;

            this.waitingText = null;


            //Logo animation
            this.tweens.add({

            targets: this.logo,
            duration: 1000,
            scaleX: 3.75,
            scaleY: 3.75,

            //Sine.easeInOut
            ease: 'Phaser.Math.Easing.Linear',
            repeat: -1,
            yoyo: true
            });
           
        }

        update(){
            frame += 1;
            //Yeah eventually this is gonna overflow but idc LOL!.
            bgX += 0.5;
            bgY -= 0.5;
            container.style.backgroundPositionX = bgX + "px";
            container.style.backgroundPositionY = bgY + "px";

            if(frame % 60 == 0){
                //Avoid overflowidk;
                frame = 0;
                this.waitingUpdate();
            }
        }

        waitingUpdate(){
            if(this.waitingText != null){
                if(this.waitingText.text == "Waiting"){
                    this.waitingText.text = "Waiting.";
                }else if(this.waitingText.text == "Waiting."){
                    this.waitingText.text = "Waiting..";
                }else if(this.waitingText.text == "Waiting.."){
                    this.waitingText.text = "Waiting...";
                }else if(this.waitingText.text == "Waiting..."){
                    this.waitingText.text = "Waiting";
                }
            }
            
        }

        loadWaiting(){

            const menuGraphics = this.add.graphics();


            //CHANGE THE COLOUR!!!!!!!
            menuGraphics.fillStyle(0xFFFFFF);
            
            menuGraphics.fillRoundedRect(-308/2,-466/2,308,466,6); //Draw this at the center of menugraphics for scaling.
            //Draw other menu items here ====================================
            menuGraphics.fillStyle(0x000000,0.1);
            menuGraphics.fillRoundedRect(-308/2+16, -466/2+73, 276, 252, 6)
            

            //Add the button...


            
            //===============================================================

            //Draw text here ================================================
            
            this.waitingText = this.add.text(608, 266, "Waiting").setFontFamily('daydream').setFontSize(27).setColor('#000000').setOrigin(0.5, 0.5)
            //this.add.text(608, 581, "Server ID: 0000").setFontFamily('daydream').setFontSize(22).setColor('#000000').setOrigin(0.5, 0.5)
            

            //Ugly hack
            const wt = this.waitingText;
            //=============================================================


            menuGraphics.x = 600;
            menuGraphics.y = 460;

            const chain = this.tweens.chain({
                targets: menuGraphics,wt,
                tweens:[
                {
                    duration: 20,
                    scale: 1.025,

                },
                {
                    duration: 20,
                    scale:1
                }

                ]
            })


        }

        goToGame(){
            this.scene.start('Game');
        }
    }

    var config = {
        //type: Phaser.AUTO,
        type: Phaser.WEBGL,
        width: 1200,
        height: 800,
        parent: 'game-container',
        backgroundColor: '#562D6E',
        transparent: true,
        resolution: window.devicePixelRatio,
        scale: Phaser.Scale.Center,
        pixelArt: true,
        antialias: false,
        scene: [Menu, Game]
    };

    var game = new Phaser.Game(config);


    </script>
    <script type="text/javascript" src="net.js"></script>
    <center>
    
</center>
</body>


</html>